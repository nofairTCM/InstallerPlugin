<roblox version="4">
  <Item class="Folder" referent="0">
    <Properties>
      <string name="Name">Plugin</string>
      <string name="Name">nofairTCM_Installer_CLI</string>
    </Properties>
    <Item class="Folder" referent="1">
      <Properties>
        <string name="Name">libs</string>
      </Properties>
      <Item class="ModuleScript" referent="2">
        <Properties>
          <string name="Name">AdvancedTween</string>
          <string name="Source">local module = {}

------------------------------------
-- 기본함수, 필요 모듈 가져오기
------------------------------------
local type = typeof or type
local clock = os.clock
local tonumber = tonumber

local script = script
local EasingFunctions = require(script and script.EasingFunctions or "EasingFunctions")
local Stepped = require(script and script.Stepped or "Stepped")

local BindedFunctions = {} -- 애니메이션을 위해 프레임에 연결된 함수들

module.PlayIndex = setmetatable({},{__mode = "k"}) -- 애니메이션 실행 스택 저장하기
-- PlayIndex[Item][Property] = 0 or nil &lt;= 트윈중이지 않은 속성
-- PlayIndex[Item][Property] = 1... &lt;= 트윈중인 속성

------------------------------------
-- Easing 스타일
------------------------------------
module.EasingFunctions = {
	--// for Autocomplete
	Linear = EasingFunctions.Linear; --// 직선
	Circle = EasingFunctions.Circle; --// 사분원
	Exp2 = EasingFunctions.Exp2; --// 덜 가파른 지수 그래프
	Exp4 = EasingFunctions.Exp4; --// 더 가파른 지수 그래프
	Exp2Max4 = EasingFunctions.Exp2Max4; --// 적당히 가파른 지수 그래프
}
for i,v in pairs(EasingFunctions) do
	module.EasingFunctions[i] = v
end

module.EasingDirection = {
	Out = "Out"; -- 반전된 방향
	In  = "In" ; -- 기본방향
}

------------------------------------
-- Lerp 함수
------------------------------------
-- 이중 선형, Alpha 를 받아서 값을 구해옴
function Lerp(start,goal,alpha)
	return start + ((goal - start) * alpha)
end

-- 기본적으로 로블록스에 있는 클래스중, + - * / 과 같은 연산자 처리 메타 인덱스가 있는것들
local DefaultItems = {
	["Vector2"] = true;
	["Vector3"] = true;
	["CFrame" ] = true;
	["number" ] = true;
}

-- 예전 값,목표 값,알파를 주고 각각 해당하는 속성에 입력해줌
-- 기본적으로 모든 속성값 적용은 여기에서 이루워짐
function LerpProperties(Item,Old,New,Alpha)
	for Property,OldValue in pairs(Old) do
		local NewValue = New[Property]
		if NewValue ~= nil then
			local Type = type(OldValue)
			if DefaultItems[Type] then
				Item[Property] = Lerp(OldValue,NewValue,Alpha)
			elseif Type == "UDim2" then
				Item[Property] = UDim2.new(
					Lerp(OldValue.X.Scale ,NewValue.X.Scale ,Alpha),
					Lerp(OldValue.X.Offset,NewValue.X.Offset,Alpha),
					Lerp(OldValue.Y.Scale ,NewValue.Y.Scale ,Alpha),
					Lerp(OldValue.Y.Offset,NewValue.Y.Offset,Alpha)
				)
			elseif Type == "UDim" then
				Item[Property] = UDim.new(
					Lerp(OldValue.Scale ,NewValue.Scale ),
					Lerp(OldValue.Offset,NewValue.Offset)
				)
			elseif Type == "Color3" then
				Item[Property] = Color3.fromRGB(
					Lerp(OldValue.r*255,NewValue.r*255),
					Lerp(OldValue.g*255,NewValue.g*255),
					Lerp(OldValue.b*255,NewValue.b*255)
				)
			end
		end
	end
end

------------------------------------
-- 모듈 함수 지정
------------------------------------
-- 트윈 메서드 지정, 트윈을 만들게 됨
-- Item : 트윈할 인스턴트
-- Data : 트윈 정보들 (태이블)
	--Data.Time (in seconds, you can use 0.5 .. etc)
	--Data.Easing (function)
	--Data.Direction ("Out" , "In")
	--Data.CallBack 콜백 함수들(태이블), 예시 : 
	--Data.CallBack[0.5] = function() end 다음과 같이 쓰면 인덱스가 정확히 0.5 가 되는 순간(시간이 아니라 이징 함수에 의해 나온 값이 같아지는 순간)
	--해당 함수가 실행됨
--Properties : 트윈할 속성과 목표값 예시 : 
--Data.Properties.Position = UDim2.new(1,0,1,0) 처럼 하면 Position 속성의 목표를 1,0,1,0 으로 지정
function module:RunTween(Item,Data,Properties,Ended)
	-- 시간 저장
	local Time = Data.Time or 1
	local EndTime = clock() + Time
	
	-- 플레이 인덱스 저장
	local ThisPlayIndex = module.PlayIndex[Item] or {}
	module.PlayIndex[Item] = ThisPlayIndex
	
	-- 예전의 트윈을 덮어쓰고 현재 값을 저장함
	local NowAnimationIndex = {}
	local LastProperties = {}
	for Property,_ in pairs(Properties) do
		LastProperties[Property] = Item[Property]
		ThisPlayIndex[Property] = ThisPlayIndex[Property] ~= nil and ThisPlayIndex[Property] + 1 or 1
		NowAnimationIndex[Property] = ThisPlayIndex[Property]
	end
	
	-- 이징 효과 가져오기
	local Direction = Data.Direction or "Out"
	local Easing do
		local Data_Easing = Data.Easing or EasingFunctions.Exp2
		local Data_EasingType = type(Data_Easing)
		Easing = (Data_EasingType == "function" and Data_Easing) or (Data_EasingType == "table" and Data_Easing.Run)
		if Data_EasingType == "table" and Data_Easing.Reverse then
			Direction = Direction == "Out" and "In" or "Out"
		end
	end

	-- 중간중간 실행되는 함수 확인
	local CallBack = Data.CallBack
	if CallBack then
		for FncIndex,Fnc in pairs(CallBack) do
			if type(Fnc) ~= "function" or type(tonumber(FncIndex)) ~= "number" then
				CallBack[FncIndex] = nil
			end
		end
	end
	-- 스탭핑
	local Step
	Step = function()
		-- 아에 멈추게 되는 경우
		if module.PlayIndex[Item] == nil then
			table.remove(BindedFunctions,table.find(BindedFunctions,Step))
			return
		end
		
		local Now = clock()
		local Index = 1 - (EndTime - Now) / Time

		-- 속성 Lerp 수행
		if Direction == "Out" then
			LerpProperties(
				Item,
				LastProperties,
				Properties,
				Easing(Index)
			)
		else
			LerpProperties(
				Item,
				LastProperties,
				Properties,
				1 - Easing(1 - Index)
			)
		end

		-- 다른 트윈이 속성을 바꾸고 있다면(이후 트윈이) 그 속성을 건들지 않도록 없엠
		local StopByOther = true
		for Property,Index in pairs(NowAnimationIndex) do
			if Index ~= ThisPlayIndex[Property] then
				LastProperties[Property] = nil
				Properties[Property] = nil
				NowAnimationIndex[Property] = nil
			else
				StopByOther = false
			end
		end

		-- 만약 다른 트윈이 지금 트윈하고 있는 속성을 모두 먹은경우 현재 트윈을 삭제함
		if StopByOther then
			table.remove(BindedFunctions,table.find(BindedFunctions,Step))
			return
		end

		-- 끝남
		if Now >= EndTime then
			for Property,_ in pairs(Properties) do
				ThisPlayIndex[Property] = 0
			end

			local PlayIndexLen = 0
			for _,_ in pairs(ThisPlayIndex) do
				PlayIndexLen = PlayIndexLen + 1
			end
			if PlayIndexLen == 0 then
				ThisPlayIndex = nil
			end

			table.remove(BindedFunctions,table.find(BindedFunctions,Step))
			Index = 1
			if Ended then
				Ended()
			end
		end
		
		-- 중간 중간 함수 배정된것 실행
		if CallBack then
			for FncIndex,Fnc in pairs(CallBack) do
				if tonumber(FncIndex) &lt;= Index then
					Fnc()
					CallBack[FncIndex] = nil
				end
			end
		end
	end

	-- 스캐줄에 등록
	table.insert(BindedFunctions,Step)
end

-- 여러개의 개체를 트윈시킴
function module:RunTweens(Items,Data,Properties,Ended)
	local First = true
	for _,Item in pairs(Items) do
		module:RunTween(Item,Data,Properties,First and Ended)
		First = false
	end
end

-- 트윈 멈추기
function module:StopTween(Item)
	module.PlayIndex[Item] = nil
end

-- 해당 개체가 트윈중인지 반환
function module:IsTweening(Item)
	if module.PlayIndex[Item] == nil then
		return false
	end
	
	for Property,Index in pairs(module.PlayIndex[Item]) do
		if Index ~= 0 then
			return true
		end
	end
	return false
end

-- 해당 개체의 해당 프로퍼티가 트윈중인지 반환
function module:IsPropertyTweening(Item,PropertyName)
	if module.PlayIndex[Item] == nil then
		return false
	end
	
	if module.PlayIndex[Item][PropertyName] == nil then
		return false
	end
	
	return module.PlayIndex[Item][PropertyName] ~= 0
end

------------------------------------
-- 프레임 연결
------------------------------------
-- 1 프레임마다 실행되도록 해야되는 함수
-- ./Stepped.lua 에서 연결점 편집 가능
-- roblox 는 이미 연결되어 있음
function module:Stepped()
	for _,Function in pairs(BindedFunctions) do
		Function()
	end
end
Stepped:BindStep(module.Stepped)

return module</string>
        </Properties>
        <Item class="ModuleScript" referent="3">
          <Properties>
            <string name="Name">BezierCurves</string>
            <string name="Source">local module = {}

function Lerp(Alpha,Point1,Point2)
	return Point1 + ( (Point2 - Point1) * Alpha )
end

function module:Bezier(Alpha,...)
	local New = {}
	local Len = #{...}
	
	for i = 1,Len do
		if i ~= 1 then
			New[#New+1] = Lerp(Alpha,select(...,i-1),select(...,i))
		end
	end
	
	if Len &lt;= 2 then
		return New[1]
	end
	return self:Bezier(Alpha,unpack(New))
end

return module</string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="4">
          <Properties>
            <string name="Name">EasingFunctions</string>
            <string name="Source"><![CDATA[local EasingFunctions = {}

local function reverse(Index)
	return 1 - Index
end

local Linear = {} do
	Linear.Run = function(Index)
		return Index
	end
end
EasingFunctions["Linear"] = Linear

local Circle = {} do
	Circle.Run = function(Index)
		return 1-((1-Index)^2)
	end
end
EasingFunctions["Circle"] = Circle

local Exp2 = {} do
	local MinIndex = -4
	local MaxIndex = 2
	local GetIndex = function(Index)
		return Index * (MaxIndex - MinIndex) + MinIndex
	end

	local Min = math.exp(MinIndex)
	local Max = math.exp(MaxIndex) - Min

	Exp2.Reverse = true
	Exp2.Run = function(Index)
		-- Index ; max = 1 min = 0
		return (math.exp(GetIndex(Index)) - Min) / Max
	end
end
EasingFunctions["Exp2"] = Exp2

local Exp4 = {} do
	local MinIndex = -4
	local MaxIndex = 4
	local GetIndex = function(Index)
		return Index * (MaxIndex - MinIndex) + MinIndex
	end

	local Min = math.exp(MinIndex)
	local Max = math.exp(MaxIndex) - Min

	Exp4.Reverse = true
	Exp4.Run = function(Index)
		-- Index ; max = 1 min = 0
		return (math.exp(GetIndex(Index)) - Min) / Max
	end
end
EasingFunctions["Exp4"] = Exp4

local Exp2Max4 = {} do
	local MinIndex = -2
	local MaxIndex = 4
	local GetIndex = function(Index)
		return Index * (MaxIndex - MinIndex) + MinIndex
	end

	local Min = math.exp(MinIndex)
	local Max = math.exp(MaxIndex) - Min

	Exp2Max4.Reverse = true
	Exp2Max4.Run = function(Index)
		-- Index ; max = 1 min = 0
		return (math.exp(GetIndex(Index)) - Min) / Max
	end
end
EasingFunctions["Exp2Max4"] = Exp2Max4

return EasingFunctions
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="5">
          <Properties>
            <string name="Name">Stepped</string>
            <string name="Source">local IsRoblox = version and version() or nil

-- 로블록스 이외의 다른 lua 플렛폼을 위한 바인드 스탭,
-- 여기에다 프레임 앞에 실행되는 이벤트를 핸들링해서 StepFunction 을
-- 연동해주면 됨,

-- 이 함수는 한 프레임마다 트윈들을 가져와서 실행시켜줌, (만약 트윈 효과가 하나도 없으면 그냥 건너뜀)

local module = {}
function module:BindStep(StepFunction)
    if IsRoblox then
        local RunService = game:GetService("RunService")
        if RunService:IsStudio() and (not RunService:IsRunning()) and RunService:IsEdit() then
            RunService.Heartbeat:Connect(StepFunction)
        else
            RunService.Stepped:Connect(StepFunction)
        end
    else
        -- do something here
    end
end

return module</string>
          </Properties>
        </Item>
      </Item>
      <Item class="ModuleScript" referent="6">
        <Properties>
          <string name="Name">ToolbarCombiner</string>
          <string name="Source">---@diagnostic disable:undefined-global
local module = {}

function module:CreateToolbar(Title,ID)
	local Tab = shared[ID]--"qwreey.plugins.toolbarprovider"]
	if not Tab then
		local NewPlugin = PluginManager():CreatePlugin()
		local NewToolbar = NewPlugin:CreateToolbar(Title)--"Qwreey's plugins")
		
		Tab = {}
		Tab.ProviderPlugin = NewPlugin
		Tab.Toolbar = NewToolbar
		Tab.Saved = {}
		
		function Tab:CreateButton(ID,...)
			local New = Tab.Saved[ID] or NewToolbar:CreateButton(ID,...)
			
			if Tab.Saved[ID] then
				New.Icon = ""
				wait()
				New.Icon = select(2,...)

				New.Enabled = true
				New.ClickableWhenViewportHidden = false
				New:SetActive(false)
			else
				New.Parent = NewPlugin
				Tab.Saved[ID] = New
			end
			
			return New
		end
		
		shared[ID] = Tab--"qwreey.plugins.toolbarprovider"] = Tab
	end
	
	return Tab
end

return module</string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="7">
        <Properties>
          <string name="Name">termRBLX</string>
          <string name="Source">---@diagnostic disable:undefined-global

if not script then
    print ("THIS IS NOT ROBLOX LUA SANDBOX!");
    print ("this lua code must be running on rblx lua sandbox");
    error ("glboal 'script' was not found")
end

local module = {};

function module.init(env)
    local runtimeModule = script.runtime:FindFirstChild(env.runtimeType);
    if not runtimeModule then
        error(("Runtime %s was not found!"):format(tostring(env.runtimeType)));
    end
    local runtime = require(runtimeModule)(env);
    return runtime;
end

return module;</string>
        </Properties>
        <Item class="Folder" referent="8">
          <Properties>
            <string name="Name">cmds</string>
          </Properties>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">cd</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"cd","cdir","cwd","chdir","chd","chwd"};
    info = "change working directory (cwd)";
    use = "cd [dir] [option]";
    help = [[
        move to game directory : cd \game
        move to parent directory : cd ..
        move to child directory : cd childName
        move to directory that includeds space : cd .\ like this\
        move to Workspace : cd \game\Workspace
        move with var : cd %client%\PlayerGui
    ]];
    exe = function (str,content,self,cmdprefix)
        local str,opt = content.splitDirOpt(str);
        str = str or "";
        local path;
        if string.sub(str,1,2) == ".\\" then
            path = content.path;
            str = string.sub(str,3,-1);
        elseif string.upper(string.sub(str,1,5)) == "\\GAME" then
            path = game;
            str = string.sub(str,6,-1);
        elseif string.upper(string.sub(str,1,5)) == "\\NULL" then
            path = nil;
            str = string.sub(str,6,-1);
        elseif string.sub(str,1,1) == "\\" then
            path = nil;
            str = string.sub(str,2,-1);
        else
            path = content.path;
        end
        str = "\\" .. str;
        local npath,err = content.toInstance(content.toPath(path) .. str,true);
        content.path = err and content.path or npath;
        content.output(content.toPath(content.path) .. "\n\n");
        if err then
            content.error("could not be found path");
        end
    end;
};
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">clear</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"clear","cls"};
    info = "clear screen (set stdout to \"\" and refresh screen)";
    use = "cd [dir] [option]";
    exe = function (str,content,self,cmdprefix)
        content.stdioSimulate:clearOutput();
    end;
};
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="11">
            <Properties>
              <string name="Name">echo</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"echo","print","output"};
    info = "add str on output";
    use = "echo [str]";
    exe = function (str,content,self,cmdprefix)
        content.output(str .. "\n");
    end;
};
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="12">
            <Properties>
              <string name="Name">pnull</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"pnull"};
    info = "print null folder's items";
    exe = function (str,content,self,cmdprefix)
        for ins,id in pairs(content.NULL) do
            content.output(id .. " : " .. ins.Name .. "\n");
        end
        content.output("\n");
    end;
};
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="13">
            <Properties>
              <string name="Name">pwd</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"pwd","pdir","pd"};
    info = "print working directory on screen";
    exe = function (str,content,self,cmdprefix)
        content.output(content.toPath(content.path) .. "\n\n");
    end;
};
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="14">
            <Properties>
              <string name="Name">rmline</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return {
    names = {"rmline","rline"};
    info = "remove last line on screen";
    exe = function (str,content,self,cmdprefix)
        local stds = content.stdioSimulate;
        local out = (string.match(string.sub(stds:getOutput(),1,-#(cmdprefix .. str)),"(.+)\n.-$") or "");
        stds:setOutput(out);
    end;
};
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="15">
          <Properties>
            <string name="Name">info</string>
            <string name="Source">return {
    version = "0.11.8";
};</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="16">
          <Properties>
            <string name="Name">render</string>
          </Properties>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">CustomScroll</string>
              <string name="Source">---@diagnostic disable:undefined-global
---@diagnostic disable:undefined-field

local module = {}

-- Roblox service load
local UserInputService = game:GetService("UserInputService")
local Run = game:GetService("RunService")
local RepSt = game:GetService("ReplicatedStorage")

-- default settings
local DefaultXMaxOverScroll = 80
local DefaultYMaxOverScroll = 80

-- module load
--local deps = RepSt:WaitForChild("rojo")
local AdvancedTween = require(script.Parent.Parent.Parent.AdvancedTween);--deps:WaitForChild("AdvancedTween"))

-- player
local LocalPlayer = game.Players.LocalPlayer
local Mouse = LocalPlayer and LocalPlayer:GetMouse()

-- input types
local InputTypes = {
	[Enum.UserInputType.Touch] = true;
	[Enum.UserInputType.MouseButton1] = true;
}

function module.new(Data)
	local Data = Data or {}
	
	-- 얼마나 오버스크롤 될 지 결정,
	-- 만약 X 오버스크롤이 0 이면 옆으로는 통통 튀는 효과가 없어짐
	-- = ios 스크롤 같은 효과 낼 수 있음
	local XMaxOverScroll = Data.XMaxOverScroll or DefaultXMaxOverScroll
	local YMaxOverScroll = Data.YMaxOverScroll or DefaultYMaxOverScroll
	
	-- 드래그 불가능한지 결정
	local DragToScrollDisabled = Data.DragToScrollDisabled
	-- 휠 사용 불가능한지 결정
	local MouseWheelDisabled = Data.MouseWheelDisabled
	
	-- 오버스크롤을 포함한 위치
	local TmpPosX
	local TmpPosY
	-- 오버스크롤 없이 홀더 크기에 맞게 잘라낸 위치
	local CutPosX
	local CutPosY
	
	-- 오브젝트 가져옴
	local Frame = Data.Obj or script.SpringScrollingFrame:Clone() -- 프레임(창)
	local Holder = Frame.Holder -- 홀더(내부)
	
	-- 스크롤 함수 (방향만큼 감)
	local function Scroll(DirectionX,DirectionY,IsMouse)
		DirectionX = DirectionX or 0
		DirectionY = DirectionY or 0
		
		local Frame_AbsoluteSize = Frame.AbsoluteSize
		local Holder_AbsoluteSize = Holder.AbsoluteSize
		
		local MinScrollPosX = Frame_AbsoluteSize.X - Holder_AbsoluteSize.X
		local MinScrollPosY = Frame_AbsoluteSize.Y - Holder_AbsoluteSize.Y
		
		-- 홀더 사이즈가 창 사이즈보다 작은 특수한 경우
		local SubX = MinScrollPosX > XMaxOverScroll and (MinScrollPosX/2) or 0
		local SubY = MinScrollPosY > YMaxOverScroll and (MinScrollPosY/2) or 0
		MinScrollPosX = math.min(0,MinScrollPosX) + SubX
		MinScrollPosY = math.min(0,MinScrollPosY) + SubY
 		
		-- 오버스크롤을 포함한 위치
		TmpPosX = math.clamp(
			(TmpPosX or Holder.Position.X.Offset) + DirectionX,
			MinScrollPosX - XMaxOverScroll,
			XMaxOverScroll + SubX
		)
		TmpPosY = math.clamp(
			(TmpPosY or Holder.Position.Y.Offset) + DirectionY,
			MinScrollPosY - YMaxOverScroll,
			YMaxOverScroll + SubY
		)
		-- 완전히 들어맞는 위치
		CutPosX = math.clamp(TmpPosX,MinScrollPosX,SubX)
		CutPosY = math.clamp(TmpPosY,MinScrollPosY,SubY)
		
		local TweenData = {
			Time = 0.4;
			Easing = AdvancedTween.EasingFunctions.Exp2;
			Direction = AdvancedTween.EasingDirection.Out;
		}
		if not IsMouse then
			TweenData.CallBack = {
				[0.4] = function()
					if CutPosX and CutPosY and (TmpPosX ~= CutPosX or TmpPosY ~= CutPosY) then
						AdvancedTween:RunTween(Holder,{
							Time = 0.85;
							Easing = AdvancedTween.EasingFunctions.Exp2;
							Direction = AdvancedTween.EasingDirection.Out;
						},{
							Position = UDim2.fromOffset(CutPosX,CutPosY);
						})
						TmpPosX = nil
						TmpPosY = nil
					end
				end;
			}
		end
		
		AdvancedTween:RunTween(Holder,TweenData,{
			Position = UDim2.fromOffset(TmpPosX,TmpPosY);
		})
	end
	
	-- 마우스 휠 앞/뒤 이벤트 연결
	-- (차피 RBX 인스턴트들은 Destroy() 호출시 연결된 이벤트가 자동으로 끊김)
	-- = 따로 연결 끊을 필요 없음
	local function WheelBackward()
		if MouseWheelDisabled then
			return
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
			-- 나중에 확대/축소 같은거 만들게 되면 편하라고 컨트롤키는 뺌
			return
		end
		local XScroll = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) -- 쉬프트 눌러서 좌우로 움직이는거
		Scroll(
			XScroll and -50,
			(not XScroll) and -50
		)
	end
	Frame.MouseWheelBackward:Connect(WheelBackward)

	local function WheelForward()
		if MouseWheelDisabled then
			return
		end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
			-- 나중에 확대/축소 같은거 만들게 되면 편하라고 컨트롤키는 뺌
			return
		end
		local XScroll = UserInputService:IsKeyDown(Enum.KeyCode.LeftShift) -- 쉬프트 눌러서 좌우로 움직이는거
		Scroll(
			XScroll and 50,
			(not XScroll) and 50
		)
	end
	Frame.MouseWheelForward:Connect(WheelForward)
	
	-- 홀더 크기 변경됨 (위치 조정)
	Holder:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
		Scroll(0,0)
	end)
	
	-- 마우스가 나갔거나 마우스 드래그가 취소됨
	-- 이 경우 그냥 Moved 연결 끊어서 멈춤(최적화 이득)
	local CheckInputEndedConnect
	local MouseMoveConnect
	local function DisconnectMoveConnect()
		if MouseMoveConnect then
			-- 오버스크롤 없는 위치로 돌아감
			AdvancedTween:RunTween(Holder,{
				Time = 0.85;
				Easing = AdvancedTween.EasingFunctions.Exp2;
				Direction = AdvancedTween.EasingDirection.Out;
			},{
				Position = UDim2.fromOffset(CutPosX,CutPosY);
			})
			TmpPosX = nil
			TmpPosY = nil
			MouseMoveConnect:Disconnect()
		end
		MouseMoveConnect = nil
		if CheckInputEndedConnect then
			CheckInputEndedConnect:Disconnect()
		end
		CheckInputEndedConnect = nil
	end
	
	-- 마우스 움직임 감지 함수
	-- 기존 위치에서 변화량을 가져와서 전체 값에 합산함
	local LastMovePosX = 0
	local LastMovePosY = 0
	local IsMoving = false
	local function MouseMove(x,y)
		if IsMoving then
			return
		end
		
		x = x or (Mouse.X + 36)
		y = y or (Mouse.Y + 36)
		
		IsMoving = true
		Scroll((x-LastMovePosX)*1.2,(y-LastMovePosY)*1.2,true)
		LastMovePosX = x
		LastMovePosY = y
		Run.Heartbeat:Wait() -- Tween 을 기다리기 위함
		IsMoving = false
	end
	
	-- 마우스 나감
	Frame.MouseLeave:Connect(DisconnectMoveConnect)
	--Frame.MouseButton1Up:Connect(DisconnectMoveConnect)
	-- 드래깅 취소
	local function CheckInputEnded(Input)
		-- gameProcessedEvent 안 받아도 됨, 그러면 버튼 위에서 떨어져 나간
		-- 인풋을 먹어버려서 안됨
		
		if InputTypes[Input.UserInputType] or Frame.Parent == nil then
			DisconnectMoveConnect()
		end
	end
	-- 드래깅 시작
	Frame.MouseButton1Down:Connect(function(x,y)
		if DragToScrollDisabled then
			return
		end
		LastMovePosX = x
		LastMovePosY = y
		-- 플긴 서비스를 위해 UserInputService.Mouse 를 남겨둠(내 모듈중 PluginGuiInputService 가 있다는 점 고려)
		MouseMoveConnect = (Mouse and Mouse.Move or UserInputService.Mouse.Move):Connect(MouseMove)
		-- 인풋 끝남과 연결
		CheckInputEndedConnect = UserInputService.InputEnded:Connect(CheckInputEnded)
	end)
	
	return Frame,setmetatable({
		Scroll = Scroll;
		WheelForward = WheelForward;
		WheelBackward = WheelBackward;
	},{
		__index = function(self,Key)
			if Key == "XMaxOverScroll" then
				return XMaxOverScroll
			elseif Key == "YMaxOverScroll" then
				return YMaxOverScroll
			elseif Key == "DragToScrollDisabled" then
				return DragToScrollDisabled
			elseif Key == "MouseWheelDisabled" then
				return MouseWheelDisabled
			end
		end;
		__newindex = function(self,Key,Value)
			if Key == "XMaxOverScroll" then
				XMaxOverScroll = Value
			elseif Key == "YMaxOverScroll" then
				YMaxOverScroll = Value
			elseif Key == "DragToScrollDisabled" then
				DragToScrollDisabled = Value
			elseif Key == "MouseWheelDisabled" then
				MouseWheelDisabled = Value
			end
		end;
	})
end

-- 끝ㅌㅌㅌㅌㅌ
return module</string>
            </Properties>
            <Item class="TextButton" referent="18">
              <Properties>
                <string name="Name">SpringScrollingFrame</string>
                <bool name="Active">true</bool>
                <Vector2 name="AnchorPoint">
                  <X>0</X>
                  <Y>0</Y>
                </Vector2>
                <BinaryString name="AttributesSerialize">
                </BinaryString>
                <bool name="AutoButtonColor">false</bool>
                <bool name="AutoLocalize">true</bool>
                <token name="AutomaticSize">0</token>
                <Color3 name="BackgroundColor3">
                  <R>1</R>
                  <G>1</G>
                  <B>1</B>
                </Color3>
                <float name="BackgroundTransparency">1</float>
                <Color3 name="BorderColor3">
                  <R>0.10588236153125763</R>
                  <G>0.16470588743686676</G>
                  <B>0.20784315466880798</B>
                </Color3>
                <token name="BorderMode">0</token>
                <int name="BorderSizePixel">1</int>
                <bool name="ClipsDescendants">true</bool>
                <bool name="Draggable">false</bool>
                <token name="Font">0</token>
                <int name="LayoutOrder">0</int>
                <float name="LineHeight">1</float>
                <bool name="Modal">false</bool>
                <Ref name="NextSelectionDown">null</Ref>
                <Ref name="NextSelectionLeft">null</Ref>
                <Ref name="NextSelectionRight">null</Ref>
                <Ref name="NextSelectionUp">null</Ref>
                <UDim2 name="Position">
                  <XS>0</XS>
                  <XO>0</XO>
                  <YS>0</YS>
                  <YO>0</YO>
                </UDim2>
                <bool name="RichText">false</bool>
                <Ref name="RootLocalizationTable">null</Ref>
                <float name="Rotation">0</float>
                <bool name="Selectable">true</bool>
                <bool name="Selected">false</bool>
                <Ref name="SelectionImageObject">null</Ref>
                <UDim2 name="Size">
                  <XS>1</XS>
                  <XO>0</XO>
                  <YS>1</YS>
                  <YO>0</YO>
                </UDim2>
                <token name="SizeConstraint">0</token>
                <int name="SourceAssetId">-1</int>
                <token name="Style">0</token>
                <BinaryString name="Tags">
                </BinaryString>
                <string name="Text">Button</string>
                <Color3 name="TextColor3">
                  <R>0.10588236153125763</R>
                  <G>0.16470588743686676</G>
                  <B>0.20784315466880798</B>
                </Color3>
                <bool name="TextScaled">false</bool>
                <float name="TextSize">8</float>
                <Color3 name="TextStrokeColor3">
                  <R>0</R>
                  <G>0</G>
                  <B>0</B>
                </Color3>
                <float name="TextStrokeTransparency">1</float>
                <float name="TextTransparency">1</float>
                <token name="TextTruncate">0</token>
                <bool name="TextWrapped">false</bool>
                <token name="TextXAlignment">2</token>
                <token name="TextYAlignment">1</token>
                <bool name="Visible">true</bool>
                <int name="ZIndex">1</int>
              </Properties>
              <Item class="Frame" referent="19">
                <Properties>
                  <string name="Name">Holder</string>
                  <bool name="Active">false</bool>
                  <Vector2 name="AnchorPoint">
                    <X>0</X>
                    <Y>0</Y>
                  </Vector2>
                  <BinaryString name="AttributesSerialize">
                  </BinaryString>
                  <bool name="AutoLocalize">true</bool>
                  <token name="AutomaticSize">0</token>
                  <Color3 name="BackgroundColor3">
                    <R>1</R>
                    <G>1</G>
                    <B>1</B>
                  </Color3>
                  <float name="BackgroundTransparency">1</float>
                  <Color3 name="BorderColor3">
                    <R>0.10588236153125763</R>
                    <G>0.16470588743686676</G>
                    <B>0.20784315466880798</B>
                  </Color3>
                  <token name="BorderMode">0</token>
                  <int name="BorderSizePixel">1</int>
                  <bool name="ClipsDescendants">false</bool>
                  <bool name="Draggable">false</bool>
                  <int name="LayoutOrder">0</int>
                  <Ref name="NextSelectionDown">null</Ref>
                  <Ref name="NextSelectionLeft">null</Ref>
                  <Ref name="NextSelectionRight">null</Ref>
                  <Ref name="NextSelectionUp">null</Ref>
                  <UDim2 name="Position">
                    <XS>0</XS>
                    <XO>0</XO>
                    <YS>0</YS>
                    <YO>0</YO>
                  </UDim2>
                  <Ref name="RootLocalizationTable">null</Ref>
                  <float name="Rotation">0</float>
                  <bool name="Selectable">false</bool>
                  <Ref name="SelectionImageObject">null</Ref>
                  <UDim2 name="Size">
                    <XS>0.5</XS>
                    <XO>0</XO>
                    <YS>0.5</YS>
                    <YO>0</YO>
                  </UDim2>
                  <token name="SizeConstraint">0</token>
                  <int name="SourceAssetId">-1</int>
                  <token name="Style">0</token>
                  <BinaryString name="Tags">
                  </BinaryString>
                  <bool name="Visible">true</bool>
                  <int name="ZIndex">1</int>
                </Properties>
                <Item class="UIListLayout" referent="20">
                  <Properties>
                    <string name="Name">UIListLayout</string>
                    <BinaryString name="AttributesSerialize">
                    </BinaryString>
                    <token name="FillDirection">1</token>
                    <token name="HorizontalAlignment">0</token>
                    <UDim name="Padding">
                      <S>0</S>
                      <O>20</O>
                    </UDim>
                    <token name="SortOrder">2</token>
                    <int name="SourceAssetId">-1</int>
                    <BinaryString name="Tags">
                    </BinaryString>
                    <token name="VerticalAlignment">1</token>
                  </Properties>
                </Item>
              </Item>
            </Item>
          </Item>
          <Item class="ModuleScript" referent="21">
            <Properties>
              <string name="Name">screenMain</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

return function (env)
    -- make scroll
    local holder,customScroll = require(script.Parent.CustomScroll).new {
        DragToScrollDisabled = true;
    };
    holder.Parent = env.holder;
    holder.Holder.Size = UDim2.fromScale(1,1);

    -- make term screen
    local termScreen = require(script.Parent.term.screen)(holder.Holder);
    termScreen.BackgroundTransparency = 1;

    -- scroll input
    termScreen.TextScreen.MouseWheelBackward:Connect(function ()
        if termScreen.TextScreen:IsFocused() then
            customScroll.WheelBackward();
        end
    end);
    termScreen.TextScreen.MouseWheelForward:Connect(function ()
        if termScreen.TextScreen:IsFocused() then
            customScroll.WheelForward();
        end
    end);

    -- set texts size
    local lastWinsizeY = math.huge;
    local function refreshScrollSize()
        local winHolderSize = holder.AbsoluteSize.Y;
        local textScreenSize = termScreen.TextScreen.TextBounds.Y + 8 + termScreen.TextScreen.TextSize;
        local winsizeY = math.max(winHolderSize,textScreenSize);
        holder.Holder.Size = UDim2.new(1,0,0,winsizeY);

        -- set scroll pos
        if winHolderSize ~= winsizeY then
            local change = winsizeY - lastWinsizeY;
            if change > 0 then
                customScroll.Scroll(0,-change -6);
            end
            lastWinsizeY = winsizeY;
        end
    end
    termScreen.TextScreen:GetPropertyChangedSignal("TextBounds"):Connect(refreshScrollSize);
    holder:GetPropertyChangedSignal("AbsoluteSize"):Connect(refreshScrollSize);

    return {
        TextScreen = termScreen.TextScreen;
        holder = holder;
    };
end;
]]></string>
            </Properties>
          </Item>
          <Item class="Folder" referent="22">
            <Properties>
              <string name="Name">term</string>
            </Properties>
            <Item class="ModuleScript" referent="23">
              <Properties>
                <string name="Name">render</string>
                <string name="Source"><![CDATA[local module = {};

local function new(ClassName,prop)
    local new = Instance.new(ClassName);
    for index,value in pairs(prop) do
        local valueType = typeof(value);
        local indexType = typeof(index);

        -- child
        if indexType ~= "string" and valueType == "Instance" then
            value.Parent = new;
        elseif valueType == "function" then
            -- connect event
            if index ~= "whenCreated" then
                new[index]:Connect(value);
            end
        elseif indexType == "string" then
            -- property
            new[index] = value
        end
    end
    local whenCreated = prop["whenCreated"];
    if whenCreated then
        whenCreated(new);
    end
    return new;
end

function module.Import(ClassName)
    return function (prop)
        if type(prop) == "string" then
            local lastName = prop;
            return function (nprop)
                nprop.Name = lastName;
                return new(ClassName,nprop);
            end;
        end
        return new(ClassName,prop);
    end;
end

return module;
]]></string>
              </Properties>
            </Item>
            <Item class="ModuleScript" referent="24">
              <Properties>
                <string name="Name">screen</string>
                <string name="Source">---@diagnostic disable:undefined-global

local render = require(script.Parent.render);
if not true then render = require("src.render.term.render"); end

local FrameEl = render.Import("Frame");
local TextBoxEl = render.Import("TextBox");
local UIPaddingEl = render.Import("UIPadding");

return function(Parent)
    return FrameEl {
        BackgroundColor3 = Color3.fromRGB(18,18,18);
        BorderSizePixel = 0;
        Parent = Parent or script;
        Name = "Background";
        ZIndex = 1;
        Size = UDim2.fromScale(1,1);
        TextBoxEl ("TextScreen") {
            BorderSizePixel = 0;
            BackgroundTransparency = 1;
            Size = UDim2.new(1,0,1,300);
            ClearTextOnFocus = false;
            ZIndex = 4;
            TextSize = 16;
            TextWrapped = true;
            Font = Enum.Font.Code;
            TextColor3 = Color3.fromRGB(230,230,230);
            TextXAlignment = Enum.TextXAlignment.Left;
            TextYAlignment = Enum.TextYAlignment.Top;
            UIPaddingEl ("Padding") {
                PaddingLeft = UDim.new(0,8);
                PaddingRight = UDim.new(0,8);
                PaddingTop = UDim.new(0,8);
            };
        };
    };
end;</string>
              </Properties>
            </Item>
          </Item>
        </Item>
        <Item class="Folder" referent="25">
          <Properties>
            <string name="Name">runtime</string>
          </Properties>
          <Item class="ModuleScript" referent="26">
            <Properties>
              <string name="Name">screen</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global
return function (env)
    local info = require(script.Parent.Parent.info); -- get termRBLX info
    local uiHost = require(script.Parent.Parent.render.screenMain)(env); -- setup uiHost
    local TextScreen = uiHost.TextScreen; -- get text screen

    -- setup std in/out put host
    local stdioSimulate = require(script.Parent.Parent.term.stdioSimulate);

    -- setup terminal host and return term env
    return require(script.Parent.Parent.term).new {
        stdioSimulate = stdioSimulate;
        uiHost = uiHost;
        TextScreen = TextScreen;
        info = info;
        env = env;
    };
end;
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="ModuleScript" referent="27">
          <Properties>
            <string name="Name">term</string>
            <string name="Source">---@diagnostic disable:undefined-global

local module = {};

function module.new(settings)
    local TextScreen = settings.TextScreen;
    local info = settings.info;
    settings.sysDebug = "";
    settings.sysDebugHook = settings.sysDebugHook;
    settings.path = settings.env.path or game;
    settings.NULL = {};
    settings.VAR = {};
    settings.toPath = require(script.Parent.utils.instanceToPath)(settings);
    settings.toInstance = require(script.Parent.utils.pathToInstance)(settings);
    settings.splitDirOpt = require(script.Parent.utils.splitDirOpt);
    settings.makeSeed = require(script.Parent.utils.makeSeed);
    settings.makeId = require(script.Parent.utils.makeId);
    settings.nullHandle = require(script.Parent.utils.nullHandle)(settings);

    -- new stdio simulate
    settings.stdioSimulate = settings.stdioSimulate.new {
        -- screen updater / screen init
        output = ("termRBLX (Version %s)\nmore info for : https://github.com/qwreey75/RbxTermi\n\n"):format(
            info.version
        );
        prompt = settings.env.prompt or "@termRBLX $ ";
        updateFunc = function (text)
            TextScreen.Text = text;
        end;

        -- cursor handle
        setCurPos = function (curPos)
            TextScreen.CursorPosition = curPos;
            TextScreen.SelectionStart = -1;
        end;
        addCurPos = function (move)
            TextScreen.CursorPosition = TextScreen.CursorPosition + move;
            TextScreen.SelectionStart = -1;
        end
    };
    local stdioSimulate = settings.stdioSimulate;
    local block = (not settings.env.disableBlock) and require(script.blockInput).new(settings.TextScreen,stdioSimulate);
    settings.output = function (text)
        stdioSimulate:addOutput(text);
    end;

    -- catch text changed
    local function update()
        stdioSimulate:updateBuffer(TextScreen.Text);
    end
    TextScreen:GetPropertyChangedSignal("Text"):Connect(update);
    update();

    -- load commands
    local cmds = {};
    local function loadCmd(t)
        for _,name in pairs(t.names) do
            cmds[name] = t;
        end
    end
    local customCmds = settings.cmds;
    if customCmds then
        for _,v in pairs(customCmds) do
            loadCmd(v);
        end
    end
    for _,cmdModule in pairs(script.Parent.cmds:GetChildren()) do
        local pass,cmd = pcall(require,cmdModule);
        if pass then
            loadCmd(cmd);
        else
            settings.output(
                ("loading command '%s' was failed, please check command module/script/path is exist and make sure command have no errors\nError Info : %s\n\n"):format(
                    cmdModule.Name,cmd
                )
            );
        end
    end
    settings.loadCmd = loadCmd;
    settings.cmds = cmds;

    -- execute input
    local exe = require(script.exe).init(settings);
    settings.exe = function (str)
        exe:run(str);
    end

    -- catch enter
    TextScreen.FocusLost:Connect(function (enter)
        if not enter then
            return;
        end

        local input = stdioSimulate:returnInput();
        wait(); TextScreen:CaptureFocus();
        exe:run(input); return;
    end);

    return settings;
end

return module;</string>
          </Properties>
          <Item class="ModuleScript" referent="28">
            <Properties>
              <string name="Name">blockInput</string>
              <string name="Source">-- block inputs when cursor is on output
-- and move cursor to input pos

local module = {};
local strLen = utf8.len;

function module.new(textbox,stdio)
    -- update editable status
    local function update()
        local outBufferSize = strLen(stdio.withoutInput) - 1;
        local selectionStart = textbox.SelectionStart;
        textbox.TextEditable = (textbox.CursorPosition > outBufferSize) and
        (selectionStart == -1 or (textbox.SelectionStart > outBufferSize));
    end

    -- sync event
    textbox:GetPropertyChangedSignal("CursorPosition"):Connect(update);
    textbox:GetPropertyChangedSignal("SelectionStart"):Connect(update);
    textbox:GetPropertyChangedSignal("Text"):Connect(update);
    return;
end

return module;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="29">
            <Properties>
              <string name="Name">exe</string>
              <string name="Source">---@diagnostic disable:undefined-global

local module = {};

function module.init(data)
    local this = {
        global = {};
    };
    local cmds = data.cmds;
    local termColor = require(script.Parent.Parent.utils.termColor);
    local red = termColor.new(termColor.names.red);

    data.error = function (str)
        data.output((red "termRBLX Error : %s"):format(
            tostring(str)
        ) .. "\n\n");
    end

    function this:run(str)
        if not str then
            return; -- locked, error etc
        end
        local cmd = string.match(str,"^[^%s]+") or "";
        local cmdObj = cmds[cmd];

        if cmdObj then
            data.global = self.global;
            data.nullHandle(data.path);
            data.stdioSimulate:setLockInput(true);
            wait();
            local pass,errmsg = pcall(cmdObj.exe,string.sub(str,#cmd + 2,-1),data,cmdObj,cmd);
            if not pass then
                data.output((red "termRBLX Error : run error occur on running command/script/program!\nerror info : %s"):format(
                    tostring(errmsg)
                ) .. "\n\n");
            end
            data.stdioSimulate:setLockInput(false);
        elseif cmd == "" then
            return;
        else
            data.output(
                (red "termRBLX Error : '%s' is not a command or script or program or path, make sure that name correct and try again!"):format(cmd)
                .. "\n\n"
            );
        end
    end

    return this;
end

return module;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="30">
            <Properties>
              <string name="Name">stdioSimulate</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global

-- modules, class, etc
local stdioMeta = {}; stdioMeta.__index = stdioMeta;
local void = (function() end);
local emptyStr = "";
local strLen = string.len;--utf8.len;
local module = {};

-- update / buffer / screen / line handle
function stdioMeta:lineCheck() -- check lines and clear old lines
end
function stdioMeta:updateScreen() -- update screen
    local withoutInput = self.output .. (self.lockInput and emptyStr or self.prompt)
    self.withoutInput = withoutInput;
    local new = withoutInput .. self.input;
    self.lastScreen = new;
    self.updateFunc(new);
end
function stdioMeta:updateBuffer(screenBuffer) -- update in buffer by screen buffer (read screen and catches input)
    local screenBufferLen = strLen(screenBuffer);
    local outputPrompt = self.output .. self.prompt;
    local lenNoInput = strLen(outputPrompt);

    if self.lockInput then -- locked
        self:clearInput();
        return;
    elseif screenBuffer == self.lastScreen then -- nothing changed
        return;
    elseif screenBuffer == outputPrompt then -- no input
        self.input = emptyStr;
        self.lastScreen = screenBuffer;
        self.inputHook(emptyStr);
        return;
    elseif screenBufferLen < lenNoInput then -- overflow input to output
        self:clearInput();
        self.setCurPos(lenNoInput + 1);
        return;
    elseif string.sub(screenBuffer,1,lenNoInput) ~= outputPrompt then -- input and output is mixed
        local changedLen = screenBufferLen - strLen(self.lastScreen);
        if changedLen < 0 then -- remove on output
            local ninput = string.sub(screenBuffer,lenNoInput + changedLen + 1,-1);
            self.input = ninput;
            self.inputHook(ninput);
        end
        self:updateScreen();
        self.setCurPos(lenNoInput + 1);
        return;
    end

    -- set input
    local input = string.sub(screenBuffer,lenNoInput + 1,-1);
    if input == emptyStr then -- nothing found
        return self:clearInput();
    end
    self.input = input;
    self.inputHook(input);
    self.lastScreen = screenBuffer;
end

-- input handle
function stdioMeta:setInput(input) -- set input
    self.input = input;
    self:updateScreen();
    self.inputHook(input);
end
function stdioMeta:getInput()
    return self.input or emptyStr;
end
function stdioMeta:clearInput() -- clear input
    self.input = emptyStr;
    self:updateScreen();
    self.inputHook(emptyStr);
end
function stdioMeta:returnInput() -- enter key function, return input and clear input and eat line
    if self.lockInput then return end
    local lastInput = self.input;
    self.output = self.lastScreen .. "\n";
    self.input = emptyStr;
    self:updateScreen();
    self.inputHook(emptyStr);
    return lastInput;
end
function stdioMeta:setLockInput(lock) -- set input lock
    if self.lockInput == lock then
        return;
    end
    self.lockInput = lock;
    self.addCurPos(#self.prompt * (lock and -1 or 0));
    self:updateScreen();
    self.addCurPos(#self.prompt * (lock and 0 or 1));
end

-- output add /set
function stdioMeta:addOutput(str) -- add output
    --self:stackLine(str);
    local output = self.output .. str;
    self.output = output;
    self:updateScreen();
    self.addCurPos(#str);
    self.outputHook(output);
end
function stdioMeta:setOutput(str) -- set output
    self.outputAddHook(str);
    local cur = #str - #self.output;
    self.output = str;
    if cur < 0 then
        self.addCurPos(cur);
    end
    self:updateScreen();
    if cur > 0 then
        self.addCurPos(cur);
    end
    self.outputHook(str);
end
function stdioMeta:getOutput() -- get output
    return self.output or emptyStr;
end
function stdioMeta:clearOutput() -- clear output
    self.output = emptyStr;
    self:updateScreen();
    self.setCurPos(#self.lastScreen);
    self.outputHook(emptyStr);
end

function module.new(option)
    local class = {};

    -- screen, input, output
    class.output = option.output or emptyStr; ---@deprecated -- output string
    class.input = option.input or emptyStr; ---@deprecated -- input string
    class.lastScreen = option.lastScreen or emptyStr; ---@deprecated -- save last screen
    class.withoutInput = emptyStr; ---@deprecated -- save last screen without input
    class.prompt = option.prompt or emptyStr; ---@deprecated -- prompt

    -- hook
    --class.addOutputHook = option.addOutputHook or void; ---@deprecated -- output function hook
    class.outputHook = option.outputHook or void ---@deprecated -- output hook
    class.outputAddHook = option.outputAddHook or void ---@deprecated -- output hook
    class.inputHook = option.inputHook or void ---@deprecated -- input hook

    -- func, settings, ...
    --class.maxLines = option.maxLines or 255; ---@deprecated -- max lines
    --class.lineBuffer = option.lineBuffer or {}; ---@deprecated -- for handle lines
    class.lockInput = option.lockInput or false; ---@deprecated -- input is locked?
    class.updateFunc = option.updateFunc or void; ---@deprecated -- when updated, call this func
    class.setCurPos = option.setCurPos or void; ---@deprecated -- update cursor pos func
    class.addCurPos = option.addCurPos or void; ---@deprecated -- update cursor with relative pos func

    setmetatable(class,stdioMeta);
    return class;
end

return module;
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="31">
          <Properties>
            <string name="Name">utils</string>
          </Properties>
          <Item class="ModuleScript" referent="32">
            <Properties>
              <string name="Name">instanceToPath</string>
              <string name="Source">---@diagnostic disable:undefined-global
return function (content) return function (ins)
    local path = "";
    local lins,lpath = "","";

    while true do
        if not ins then
            local nullId = content.NULL[lins];
            if nullId then
                path = "\\NULL\\" .. nullId .. lpath;
            else
                path = "\\NULL" .. path;
            end
            break;
        elseif ins == game then
            path = "\\GAME" .. path;
            break;
        end
        lins = ins;
        lpath = path;
        path = "\\" .. ins.Name .. path;
        ins = ins.Parent;
    end

    return path;
end end;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="33">
            <Properties>
              <string name="Name">makeId</string>
              <string name="Source"><![CDATA[---@diagnostic disable:undefined-global
local WORD = {
	"a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z",
	"A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z",
	"1","2","3","4","5","6","7","8","9","0"
};
local makeSeed = require(script.Parent.makeSeed);

return function (len)
	local ID = "";
	for i = 1,(len or 18) do
		math.randomseed(makeSeed(math.pi^i,math.pi*i));
		ID = ID .. WORD[math.random(1,#WORD)];
	end
	return ID;
end;
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">makeSeed</string>
              <string name="Source"><![CDATA[local pi3 = math.pi^13/10000000;
return function (min,max)
	local rm = (collectgarbage("count")*pi3)^2 * 1000000;
	local ts = (os.clock()*pi3)^2;
	local seed = math.floor(ts*((((min/13)^2+(max/11)^2)*pi3)^2+rm));

	return seed;
end;
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">nullHandle</string>
              <string name="Source">return function (content) return function (ins)
    if not ins then
        return;
    end

    if ins.Parent then
        return;
    end

    if content.NULL[ins] then
        return;
    end

    content.NULL[ins] = content.makeId();
end end;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="36">
            <Properties>
              <string name="Name">pathToInstance</string>
              <string name="Source">---@diagnostic disable:undefined-global
---@diagnostic disable:undefined-field
return function (content) return function (path,returnErr)
    local ins = nil;
    local deep = 0;
    local er;
    for str in string.gmatch(path,"[^\\]+") do
        deep = deep + 1;
        if deep == 1 then
            if string.upper(str) == "GAME" then
                ins = game;
            elseif string.upper(str) == "NULL" then
                ins = nil;
            end
        elseif deep == 2 and ins == nil then
            ins = table.find(content.NULL,str);
        else
            if ins == nil then
                break;
            elseif str == ".." then
                ins = ins.Parent;
            elseif str == "" then
                break;
            else
                local nins = ins:FindFirstChild(str);
                if nins then
                    ins = nins;
                else
                    er = str;
                    break;
                end
            end
        end
    end
    return ins,returnErr and er;
end end;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="37">
            <Properties>
              <string name="Name">splitDirOpt</string>
              <string name="Source">-- split directory and option

return function (str)
    str = string.match(str,"^%s*(.+)") or str;
    local opt,sum = "",nil;
    for sp in string.gmatch(str,"[^%s]+") do
        if not sum then
            sum = sp;
        else
            local epos = string.find(sp,"\\");
            if epos then
                sum = sum .. opt .. sp;
                opt = "";
            else
                opt = opt .. "\32" .. sp;
            end
        end
    end
    return sum,opt;
end;</string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="38">
            <Properties>
              <string name="Name">termColor</string>
              <string name="Source">local colors = {};

local clear = "\27[0\109";
colors.clear = clear;

local cache = {};
function colors.new(colorInt)
    local cached = cache[colorInt];
    if cached then
        return cached;
    end

	local colorStr = ("\27[%d\109"):format(colorInt);
	local new = function(text)
		return colorStr .. text .. clear;
	end
	return new;
end

colors.names = {
    -- attributes
    clear = 0;
    bright = 1;
    dim = 2;
    underscore = 4;
    blink = 5;
    reverse = 7;
    hidden = 8;

    -- foreground
    black = 30;
    red = 31;
    green = 32;
    yellow = 33;
    blue = 34;
    magenta = 35;
    cyan = 36;
    white = 37;

    -- background
    onblack = 40;
    onred = 41;
    ongreen = 42;
    onyellow = 43;
    onblue = 44;
    onmagenta = 45;
    oncyan = 46;
    onwhite = 47;
};

return colors;</string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
    <Item class="ModuleScript" referent="39">
      <Properties>
        <string name="Name">main</string>
        <string name="Source"><![CDATA[
--[[
    # Author        : Qwreey / qwreey75@gmail.com / github:qwreey75
    # Create Time   : 2021-05-11 18:57:26
    # Modified by   : Qwreey
    # Modified time : 2021-06-05 17:37:44
    # Description   : |
        Time format = yyy-mm-dd hh:mm:ss
        Time zone = GMT+9

        모듈 다운로더 / 관리자입니다
        짅자ㅣ안ㄶ희ㅣㄴㄱ깃ㅅ헙브 넘뭏흐ㄴ네
        ㄷ돋덷ㅊ채 몇ㅊㅊ벊흘ㄹㄹ실ㄿ펱ㅌ뜬ㄴㄴㄷㄴ냑ㄱㄱ오
  ]]

local function main(plugin)
--#region [전체바탕/베이스] 플러그인 기본 베이스 가져옴 / 로블 기본 서비스를 가져옴

    -- 플러그인 베이스
    local pluginID = "nofairTCM.plugin.installerCLI"; -- 플러그인 ID
    local pluginIcon = "http://www.roblox.com/asset/?id=6031302931"; -- 플러그인 아이콘 (다크 테마를 위한)
    local pluginIconBlack = "http://www.roblox.com/asset/?id=6790472987"; -- 플러그인 아이콘 (라이트 테마를 위한)

    -- 로블록스 서비스
    local HTTP = game:GetService("HttpService"); -- HTTP 접근 서비스 / json 인코더-디코더

    -- 이 플러그인 버전 가져오기
    local verInfo = HTTP:JSONDecode(script.version.Value);
    local version = verInfo.version; -- 플러그인 버전 (x.xxx.x)
    local publishVersion = verInfo.publishVersion; -- 퍼블리시 버전

--#endregion
--#region [모듈 임포팅] 플러그인 모듈들을 불러옴 / 기초 설정을 만듬

    -- 플러그인 모듈들을 가져옴
    local commandArg = require(script.commandArg) --[[자동완성]] if not true then commandArg = require("src.commandArg"); end
    local toolbar = require(script.Parent.libs.ToolbarCombiner); --[[자동완성]] if not true then toolbar = require("libs.ToolbarCombiner.src"); end
    local installer = require(script.installer); --[[자동완성]] if not true then installer = require("src.installer"); end
    local termRBLX = require(script.Parent.libs.termRBLX); --[[자동완성]] if not true then termRBLX = require("libs.termRBLX"); end
    local commands = require(script.commands); --[[자동완성]] if not true then commands = require("scr.commands"); end

    -- 터미널 셋업
    local termTCM = termRBLX.init { -- 터미널을 하나 만듬
        runtimeType = "screen";
        holder = plugin;
        disableBlock = false;
        prompt = "$termTCM | ";
        path = plugin;
    };
    termTCM.output( -- 정보를 stdout 에 띄워줌
        ("type \"tcmi help\" for get information of tcm installer\ntcm 설치기에 대한 설명을 얻으려면 \"tcmi help\" 를 입력하세요\nTCM INSTALLER VERSION : %s\n\n-----------------Setup!-----------------\n")
        :format(version)
    );
    for _,command in pairs(commands(commandArg.decode)) do -- 커맨드를 불러와서 레지스터에 등록해둠
        termTCM.loadCmd(command);
    end

--#endregion
--#region [플러그인 바탕] 플러그인 UI / 플러그인 마우스 / 플러그인 탭 / 플러그인 버튼을 만듬

    -- 플러그인 창을 만듬
    local uiHolder = plugin:CreateDockWidgetPluginGui( -- 창을 만듬
        pluginID,
        DockWidgetPluginGuiInfo.new(
            Enum.InitialDockState.Float,
            true,
            false,
            280,
            300,
            280,
            300
        )
    );
    uiHolder.Name = pluginID; -- 플러그인 창 이름 정하기
    uiHolder.Title = "nofairTCM Installer"; -- 플러그인 창 이름(실제로 표시 되는) 정하기

    -- 툴바/버튼
    local sharedToolbar = toolbar:CreateToolbar("nofairTCM",pluginID); -- 툴바를 만듬
    local thisButton = sharedToolbar:CreateButton( -- 버튼을 만듬
        pluginID .. ".openWindow",
        "open installer",
        (tostring(settings().Studio.Theme) == "Dark") and
            pluginIcon or pluginIconBlack, -- 테마에 맞게 아이콘 수정
        "Installer CLI"
    );
    thisButton.ClickableWhenViewportHidden = true; -- 창이 가려져 있어도 버튼을 누를 수 있음
    thisButton.Click:Connect(function () -- 버튼의 클릭 이벤트를 받아서 창의 열림 상태를 편집
        uiHolder.Enabled = not uiHolder.Enabled;
    end)
    local function setButtonStatus() -- 버튼 켜짐 꺼짐 상태 지정
        thisButton:SetActive(uiHolder.Enabled);
    end
    uiHolder:GetPropertyChangedSignal("Enabled"):Connect(setButtonStatus);
    setButtonStatus();

--#endregion
--#region [데이터 로드] 데이터 불러오기 / 유저 기다리기

    if not uiHolder.Enabled then -- 창이 열릴 때 까지 기다림
        uiHolder:GetPropertyChangedSignal("Enabled"):Wait();
    end

    -- 모듈 정보를 깃허브에서 읽어옴
    local moduleData,isPass;
    local reloadList;
    local function fetch()
        moduleData,isPass = pcall(HTTP.GetAsync,HTTP,"https://raw.githubusercontent.com/nofairTCM/Package/master/packageList.json");
        if not isPass then
            termTCM.output("an error occurred on fetching database, type 'tcmi fetch' for retry");
            return;
        end
        moduleData = HTTP:JSONDecode(moduleData);
        installer:setDB(moduleData);
        termTCM.moduleData = moduleData;
        if reloadList then
            reloadList();
        end
        return moduleData;
    end;
    termTCM.fetchDB = fetch;
    termTCM.installer = installer;
    fetch();

--#endregion
--#region 터미널 랜더

    termTCM.uiHost.holder.Parent = uiHolder;
    termTCM.uiHost.holder.BackgroundTransparency = 0;
    termTCM.uiHost.holder.BackgroundColor3 = Color3.fromRGB(38,38,38);

--#endregion
end

return {
    run = main;
};]]></string>
      </Properties>
      <Item class="ModuleScript" referent="40">
        <Properties>
          <string name="Name">commandArg</string>
          <string name="Source"><![CDATA[
--[[
    # Author        : Qwreey / qwreey75@gmail.com / github:qwreey75
    # Create Time   : 2021-05-21 21:43:18
    # Modified by   : Qwreey
    # Modified time : 2021-06-05 16:21:12
    # Description   : |
        Time format = yyy-mm-dd hh:mm:ss
        Time zone = GMT+9

        커맨드 라인에서 구문을 분석하기 위해서 사용되는 모듈입니다
        -f , -a 같은 옵션자와 "" 로 묶은 옵션, \ 로 이스캐이핑한 따음표, 이외에 arg 를 처리합니다

        CLI option,arg decoder
  ]]

local module = {};

local function splitStr(str)
    local tmp = "";
    local spt = {};

    local quote = false;
    local squote = false;
    local escape = false;

    local function push()
        if tmp == "" then
            return;
        end
        table.insert(spt,tmp .. (escape and "\\" or ""));
        tmp = "";
        escape = false;
    end

    for part in string.gmatch(str,".") do
        if (not squote) and part == "\"" and (not escape) then
            quote = not quote;
            push();
        elseif (not quote) and part == "\'" and (not escape) then
            squote = not squote;
            push();
        elseif part == "\32" and (not quote) and (not squote) then
            push();
        else
            tmp = tmp .. ((escape and part == "\\") and "\\" or part);
        end
        escape = false;
        if part == "\\" then
            escape = true;
        end
    end

    if tmp ~= "" then
        table.insert(spt,tmp);
    end

    return spt;
end

function module.decode(str,optionList,optionNotFound)
    local option = {};
    local args = {};

    local split = splitStr(str);

    local lastOpt;

    local strSub = string.sub;
    local tableInsert = table.insert;
    for i,this in ipairs(split) do
        if i >= 1 then
            if strSub(this,1,1) == "-" then -- this = option
                local optName = optionList[this];
                if not optName then
                    error((optionNotFound or "option %s was not found, -h for see info"):format(this));
                end
                option[optName] = true;
                lastOpt = optName;
            elseif lastOpt then -- set option
                option[lastOpt] = this;
                lastOpt = nil;
            else
                tableInsert(args,this);
            end
        end
    end

    return args,option;
end

return module;
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="41">
        <Properties>
          <string name="Name">commands</string>
          <string name="Source"><![CDATA[
--[[
    # Author        : Qwreey / qwreey75@gmail.com / github:qwreey75
    # Create Time   : 2021-05-16 17:12:32
    # Modified by   : Qwreey
    # Modified time : 2021-06-05 17:33:50
    # Description   : |
        Time format = yyy-mm-dd hh:mm:ss
        Time zone = GMT+9

        터미널에서 installer 에 접근 할 수 있도록 command 를 만듭니다
  ]]

--[[
    tcmi install <module/libs/plugin Name>
      install object from rblx asset / github repo
      THIS ACTION IS CALL FETCHING DATABASE!

    tcmi update <module/libs/plugin Name>
      same to install, but is update only installed objects
      THIS ACTION IS CALL FETCHING DATABASE!

    tcmi isInstalled <module/libs/plugin Name>
      check object is installed on this map

    tcmi checkUpdate <module/libs/plugin Name> [option]
      check object is need to update

      option :
        -f : fetch and check version

    tcmi updateAll
      update all objects
      THIS ACTION IS CALL FETCHING DATABASE!
      same to 'tcmi update *'

    tcmi search <q> [option]
      search object from db

      option :
        -f : fetch and check version

    tcmi ls [option]
      show list of objects

      option :
        -f : fetch and show list
        -i : show installed modules
        -a : show advanced information

    tcmi info <module/libs/plugin Name> [option]
      show object's information

      option :
        -f : fetch and show info

    tcmi help [command]
      show is msg

]]

local runService = game:GetService("RunService");
local function waitHeart()
    runService.Heartbeat:Wait();
end

local props = {
    "author";
    "info";
    "version";
    "publishVersion";
    "publishStatus";
    "buildVersion";
    "majorVersion";
    "import";
    "github";
    "lic";
    "toolboxID";
    "index";
};

local header = (
    "this is tcm installer command,\n" ..
    "you can install or manage tcm module/library\n\n" ..
    "이 커맨드는 tcm 설치기를 실행합니다\n" ..
    "이 커맨드를 이용하면 모듈/라이브러리를 설치하거나 관리 할 수 있습니다\n" ..
    "명령어에 대한 자세한 사항은 아래의 메시지를 참조해주세요\n\n" ..
    "tcmi help [commandName]\n" ..
    "show command info\n\n"
);

local cmds = {
    info = {
        info = (
            "tcmi info [objectId] [options]\n" ..
            "  show object info from database\n" ..
            "  options :\n" ..
            "    -f (--fetch) : fetch and show database, (http require)\n" ..
            "    -q (--quiet) : return data only, do not show info on stdout"
        );
        options = {
            ["-f"] = "fetch";
            ["--fetch"] = "fetch";
            ["-q"] = "quiet";
            ["--quiet"] = "quiet";
        };
        exe = function (args,options,content,self)
            if options.fetch then
                content.fetchDB();
            end

            -- module name in arg
            local id = args[1];
            if id then
                local object = content.moduleData[id];

                if not object then
                    content.output(("object '%s' was not found from database! please check command arg and try again!\n\n"):format(id));
                    return;
                end
                if options.quiet then
                    return object;
                end

                local isPass,isInstalled = pcall(content.installer.isInstalled,content.installer,id);
                if not isPass then
                    content.output(("ERROR : %s\nan error occurred; ignore and continue . . .\n"):format(isInstalled));
                end
                isInstalled = isInstalled ~= nil;

                content.output("\n" .. object.name .. (" (id : %s)"):format(id)); waitHeart();
                content.output("\n  isInstalled : " .. tostring(isInstalled));
                for _,index in pairs(props) do
                    content.output("\n  " .. index .. " : " .. tostring(object[index])); waitHeart();
                end
                content.output("\n\n");

                return object;
            else
                content.output("arg 1 [objectId] is missing! please check command arg and try again!\n\n");
                return;
            end
        end;
    };
    ls = {
        info = (
            "tcmi ls [options]\n" ..
            "  show list of objects from database\n" ..
            "  options :\n" ..
            "    -f (--fetch) : fetch and show database, (http require)\n" ..
            "    -b : show name only\n" ..
            "    -q (--quiet) : return data only, do not show list on stdout\n" ..
            "    -i (--installed) : show installed objects only"
        );
        options = {
            ["-f"] = "fetch";
            ["--fetch"] = "fetch";
            ["-b"] = "nameOnly";
            ["-q"] = "quiet";
            ["--quiet"] = "quiet";
            ["-i"] = "installed";
            ["--installed"] = "installed";
        };
        exe = function (args,options,content,self)
            if options.fetch then
              content.fetchDB();
            end

            -- not module name in arg
            local nameOnly = options.nameOnly;
            local moduleData = content.moduleData;
            local installedOnly = options.installed;

            if not options.quiet then
                for id,object in pairs(moduleData) do
                    local isPass,isInstalled = pcall(content.installer.isInstalled,content.installer,id);
                    if not isPass then
                        content.output(("ERROR : %s\nan error occurred; ignore and continue . . .\n"):format(isInstalled));
                    end
                    isInstalled = isInstalled ~= nil;

                    if (not installedOnly) or isInstalled then
                        content.output("\n" .. object.name .. (" (id : %s)"):format(id));
                        if not nameOnly then
                            content.output("\n  isInstalled : " .. tostring(isInstalled));
                            for _,index in pairs(props) do
                                content.output("\n  " .. index .. " : " .. tostring(object[index]));
                            end
                            content.output("\n");
                        end
                    end
                end

                if nameOnly then
                    content.output("\n");
                end
            end
            content.output("\n");
            return moduleData;
        end;
    };
    fetch = {
        info = (
            "tcmi fetch [options]\n" ..
            "  fetch database from github\n" ..
            "  options :\n" ..
            "    -b (--background) : fetch database in background mode (coroutine)"
        );
        options = {
            ["-b"] = "background";
            ["--background"] = "background";
        };
        exe = function (args,options,content,self)
            if options.background then
                coroutine.resume(coroutine.create(function ()
                    content.fetchDB();
                end))
                return;
            end
            return content.fetchDB();
        end;
    };
    install = {
        info = (
            "tcmi install [objectId] [options]\n" ..
            "  install object from rblx asset / github repo\n" ..
            "  THIS ACTION IS CALL FETCHING DATABASE!\n" ..
            "  options :\n" ..
            "    -q (--quiet) : return data only, do not show info on stdout"
        );
        options = {
            ["-q"] = "quiet";
            ["--quiet"] = "quiet";
        };
        exe = function (args,options,content,self)
            content.fetchDB();
            -- module name in arg
            local moduleName = args[1];
            local quiet = options.quiet;
            if moduleName then
                local object = content.moduleData[moduleName];

                if not object then
                    content.output(("object '%s' was not found from database! please check command arg and try again!\n\n"):format(moduleName));
                    return;
                end

                local isPass,errmsg = pcall(content.installer.install,content.installer,moduleName,(not quiet) and content.output);
                if not isPass then
                    content.output("ERROR : " .. errmsg .. "\n");
                end
                if not quiet then
                    content.output("\n");
                end

                return object;
            else
                content.output("arg 1 [objectId] is missing! please check command arg and try again!\n\n");
                return;
            end
        end;
    };
    uninstall = {
        info = (
            "tcmi uninstall [objectId] [options]\n" ..
            "  uninstall object from this place\n" ..
            "  options :\n" ..
            "    -q (--quiet) : return data only, do not show info on stdout"
        );
        options = {
            ["-q"] = "quiet";
            ["--quiet"] = "quiet";
        };
        exe = function (args,options,content,self)
            -- module name in arg
            local moduleName = args[1];
            local quiet = options.quiet;
            if moduleName then
                local object = content.moduleData[moduleName];

                if not object then
                    content.output(("object '%s' was not found from database! please check command arg and try again!\n\n"):format(moduleName));
                    return;
                end

                local isPass,errmsg = pcall(content.installer.uninstall,content.installer,moduleName,(not quiet) and content.output);
                if not isPass then
                    content.output("ERROR : " .. errmsg .. "\n");
                end
                if not quiet then
                    content.output("\n");
                end

                return object;
            else
                content.output("arg 1 [objectId] is missing! please check command arg and try again!\n\n");
                return;
            end
        end;
    };
    init = {
        info = (
            "tcmi init\n" ..
            "  init tcm object storage\n" ..
            "  this command is auto executing by other commands!"
        );
        options = {};
        exe = function (args,options,content,self)
            local isPass,errmsg = pcall(content.installer.init,content.installer);

            if not isPass then
                content.output("ERROR : " .. errmsg .. "\n");
                return false;
            end
            return true;
        end;
    };
}

local helpMSG = header;
for _,command in pairs(cmds) do
    helpMSG = helpMSG .. command.info .. "\n\n";
end

local helpCommand = {
    ["-h"] = true;
    ["--help"] = true;
    help = true;
};

return function (decode)
    return {
        {
            names = {"tcmi"};
            info = "nofairTCM installer command";
            use = "tcmi [command] ...";
            help = helpMSG;
            exe = function (str,content,self,cmdprefix)
                local commandName = string.match(str,"[^%s]+");

                if (not commandName) or commandName == "" then
                    content.output(helpMSG);
                    return;
                elseif helpCommand[commandName] then
                    local which = string.match(string.sub(str,#commandName+1,-1),"[^%s]+");
                    local cmd = which and cmds[which];
                    if cmd then
                        content.output("\n" .. cmd.info .. "\n\n");
                    else
                        content.output(helpMSG);
                    end
                    return;
                end

                local cmd = cmds[commandName];
                if not cmd then
                    content.output(("error : command '%s' does not exist, check help to get some information!\n"):format(commandName));
                    return
                end

                local argStr = string.sub(str,#commandName + 1,-1);
                local pass,arg,opt = pcall(decode,argStr,cmd.options);

                if not pass then
                    content.output(arg .. "\n");
                    return;
                end

                return cmd.exe(arg,opt,content,cmd);
            end;
        };
    };
end;
]]></string>
        </Properties>
      </Item>
      <Item class="ModuleScript" referent="42">
        <Properties>
          <string name="Name">installer</string>
          <string name="Source"><![CDATA[
--[[
    # Author        : Qwreey / qwreey75@gmail.com / github:qwreey75
    # Create Time   : 2021-05-11 20:24:44
    # Modified by   : Qwreey
    # Modified time : 2021-06-05 16:46:19
    # Description   : |
        Time format = yyy-mm-dd hh:mm:ss
        Time zone = GMT+9

        설치 관리자입니다
  ]]

---@diagnostic disable:undefined-global
local module = {};
local ServerStorage = game:GetService("ServerStorage");
local ServerScript = game:GetService("ServerScriptService");
local ReplicatedStorage = game:GetService("ReplicatedStorage");
local ReplicatedFirst = game:GetService("ReplicatedFirst");
local HTTP = game:GetService("HttpService");
local void = function() end;

local props = {
    "name",
    "author",
    "import",
    "github",
    "lic",
    "info",
    "publishStatus",
    "version",
    "buildVersion",
    "majorVersion",
    "toolboxID",
    "index"
};
-- check thing's properties
local function checkThing(thing)
    for _,property in pairs(props) do
        assert(thing[property],property .. " is not exist!");
    end
end

-- make new instance
local function new(ClassName,Property)
    local Parent = Property and Property.Parent;
    local this = Instance.new(ClassName,Parent);

    if Parent then
        local old = Parent:FindFirstChild(Property.Name or ClassName);
        if old then
            old:Destroy();
        end
    end

    for i,v in pairs(Property) do
        this[i] = v;
    end

    return this;
end

local function replace(parent,t)
    local str = "";
    for _,o in pairs(t) do
        local oName = o.Name;
        local find = parent:FindFirstChild(oName);
        if find then
            find:Destroy();
        end
        o.Parent = parent;
        str = str .. oName .. ";";
    end

    return str;
end

local function remove(parent,t,log)
    log = log or void;
    if (not t) or (not parent) then
        return;
    elseif type(t) == "string" then
        log("decoding string . . .\n")
        local tmp = {};
        for str in string.gmatch(t,"[^;]+") do
            table.insert(tmp,str);
        end
        t = tmp;
    end
    log(("try to remove items from %s\n"):format(parent.Name));
    for _,v in pairs(t) do
        local obj = parent:FindFirstChild(v);
        if obj then
            obj:Destroy();
            log(("removed %s\n"):format(v));
        end
    end
end

-- get server side storage
function module:getServerSideStorage()
    local this = ServerStorage:FindFirstChild("nofairTCM_Server")
        or new("Folder",{Parent = ServerStorage,Name = "nofairTCM_Server"});
    return {
        this = this;
        __installer = this:FindFirstChild("__installer") or new(
            "Folder",{Parent = this,Name = "__installer"}
        );
        init = ServerScript:FindFirstChild("nofairTCM_ServerInit")
            or new("Folder",{Parent = ServerScript,Name = "nofairTCM_ServerInit"});
    };
end

-- get client side storage
function module:getClientSideStorage()
    return {
        this = ReplicatedStorage:FindFirstChild("nofairTCM_Client")
            or new("Folder",{Parent = ReplicatedStorage,Name = "nofairTCM_Client"});
        init = ReplicatedFirst:FindFirstChild("nofairTCM_ClientInit")
            or new("Folder",{Parent = ReplicatedFirst,Name = "nofairTCM_ClientInit"});
    };
end

-- set database (github)
function module:setDB(newDB)
    self.db = newDB;
end

-- get item
function module:getThing(name)
    local thing = self.db[name];
    if not thing then error(("module/plugin/lib %s was not found from database!"):format(name)) end
    checkThing(thing);
    return thing;
end

-- check is installed
function module:isInstalled(name)
    local server = self:getServerSideStorage();
    return server.__installer:FindFirstChild(name);
end

-- check update
function module:checkUpdate(name)
    local thing = self:getThing(name);
    local status = self:isInstalled(name);
    if not status then
        error(("module/lib/plugin was not found! (got : %s)"):format(name));
    end
    return thing.publishVersion > status.Value;
end

-- uninstall
function module:uninstall(name,log)
    local elog = log or void;
    local indent = indent or "";
    local log = function(str)
        wait();
        elog(indent .. str);
    end

    log(("# try to uninstall %s\n"):format(tostring(name)));
    local server = self:getServerSideStorage();
    local client = self:getClientSideStorage();

    local isInstalled = self:isInstalled(name);
    if not isInstalled then
        log(("%s not installed! (or not found)"):format(name));
        return;
    end

    local installedClient = isInstalled:FindFirstChild("client");
    local installedServer = isInstalled:FindFirstChild("server");
    local installedClientInit = isInstalled:FindFirstChild("clientInit");
    local installedServerInit = isInstalled:FindFirstChild("serverInit");

    installedClient = installedClient and installedClient.Value;
    installedServer = installedServer and installedServer.Value;
    installedClientInit = installedClientInit and installedClientInit.Value;
    installedServerInit = installedServerInit and installedServerInit.Value;

    remove(client.this,installedClient,log);
    remove(server.this,installedServer,log);
    remove(client.init,installedClientInit,log);
    remove(server.init,installedServerInit,log);

    log("remove meta data . . .\n");
    isInstalled:Destroy();
    log(("Remove %s ended!\n"):format(name));
end

-- install item
function module:install(name,log,indent)
    local elog = log or void;
    local indent = indent or "";
    local log = function(str)
        wait();
        elog(indent .. str);
    end

    log(("# try to install %s\n"):format(tostring(name)));
    log("find object from database . . .\n")
    local thing = self:getThing(name);

    log("init server/client storage . . .\n");
    local server = self:getServerSideStorage();
    local client = self:getClientSideStorage();

    local thisName = thing.name;
    local isInstalled = self:isInstalled(thisName) ~= nil;

    -- 하위 모듈들을 받아온다
    log("install submodules . . .\n");
    local import = thing.import;
    if import then
        for _,name in pairs(import) do
            self:install(name,elog,indent .. string.rep("\32",2));
        end
    end

    log("try to install objects . . .\n");
    -- 이미 있으면 지움
    if isInstalled then
        if not self:checkUpdate(thisName) then-- 이미 업데이트됨
            log("is latest version already!\n")
            return;
        end
        self:uninstall(name,elog);
    end

    -- 오브젝트 가져오기
    log("get objects from rblx asset . . .\n");
    local obj = game:GetObjects(thing.toolboxID)[1];
    if not obj then
        log("object not found");
        return;
    end

    -- 버전 파일 확인
    log("checking version . . .\n");
    local versionObj = obj:FindFirstChild("version");
    if not versionObj then
        error("version file was not found from asset");
    end
    version = HTTP:JSONDecode(versionObj.Value);
    if version.publishVersion ~= thing.publishVersion then
        error("asset publish version and github publish version does not match!, please wait for github user content refreshing");
    end

    -- setup 이 있으면 실행
    log("execute __setup script (before install) . . .\n");
    local __setup = obj:FindFirstChild("__setup");
    if __setup then
        local before = require(__setup).before;
        if before then
            before(server,client,self);
        end
    end

    local clientObj = obj:FindFirstChild("client");
    local serverObj = obj:FindFirstChild("server");
    local serverInitObj = obj:FindFirstChild("serverInit");
    local clientInitObj = obj:FindFirstChild("clientInit");

    -- 설치 상태 저장소 만들기
    log("init status objects . . .\n");
    local status = new("IntValue",{
        Name = thisName;
        Parent = server.__installer;
        Value = thing.publishVersion;
    });

    -- 클라이언트 오브젝트 인스톨
    log("move client objects . . .\n");
    if clientObj then
        new("StringValue",{
            Parent = status;
            Name = "client";
            Value = replace(client.this,clientObj:GetChildren());
        });
    end

    -- 서버 오브젝트 인스톨
    log("move server objects . . .\n");
    if serverObj then
        new("StringValue",{
            Parent = status;
            Name = "server";
            Value = replace(server.this,serverObj:GetChildren());
        });
    end

    -- 클라이언트 초기화기 인스톨
    log("move client init script . . .\n");
    if clientInitObj then
        new("StringValue",{
            Parent = status;
            Name = "clientInit";
            Value = replace(client.init,clientInitObj:GetChildren());
        });
    end

    -- 서버 초기화기 인스톨
    log("move server init script . . .\n");
    if serverInitObj then
        new("StringValue",{
            Parent = status;
            Name = "serverInit";
            Value = replace(server.init,serverInitObj:GetChildren());
        });
    end

    -- 임포트 해온거 기록해두기
    log("saving import list . . .\n");
    local importStr = "";
    if import then
        for _,v in pairs(import) do
            importStr = i .. ";";
        end
    end
    new("StringValue",{
        Parent = status;
        Name = "import";
        Value = importStr;
    });

    -- 지울때 쓰이는 __uninstall 저장하기
    log("saving __uninstall script . . .\n");
    local __uninstall = obj:FindFirstChild("__uninstall");
    if __uninstall then
        __uninstall.Parent = status;
    end

    -- version 파일 이동
    versionObj.Parent = status;

    -- setup 이 있으면 실행
    log("execute __setup script (after install) . . .\n");
    if __setup then
        local after = require(__setup).after;
        if after then
            after(server,client,self);
        end
    end

    log(("Install '%s' ended!\n"):format(thisName));
end

-- init
function module:init()
    local server = self:getServerSideStorage();
    local client = self:getClientSideStorage();
    return {server = server,client = client};
end;

-- get installed object
function module:getInstalledObjs()
    return self.db;
end

return module;]]></string>
        </Properties>
      </Item>
      <Item class="Script" referent="43">
        <Properties>
          <string name="Name">runtime</string>
          <string name="Source"><![CDATA[
--[[
    # Author        : Qwreey / qwreey75@gmail.com / github:qwreey75
    # Create Time   : 2021-05-15 18:13:03
    # Modified by   : Qwreey
    # Modified time : 2021-05-16 17:58:03
    # Description   : |
        Time format = yyy-mm-dd hh:mm:ss
        Time zone = GMT+9

        init 를 호출하고 초기화 오류를 캐칭합니다
  ]]

---@diagnostic disable:undefined-global

local initPass,msg = pcall (function ()
    local app = require(script.Parent);
    app.run(plugin);

    app.status = "ENABLED";
end);

if not initPass then
    error (("플러그인 초기화중 오류가 발생하였습니다, 오류 내용은 다음과 같습니다 : %s"):format(msg))
end
]]></string>
        </Properties>
      </Item>
      <Item class="StringValue" referent="44">
        <Properties>
          <string name="Name">version</string>
          <string name="Value">{
    "version": "1.14.221",
    "buildVersion": 221,
    "publishVersion": 14,
    "majorVersion": 1
}</string>
        </Properties>
      </Item>
    </Item>
  </Item>
</roblox>